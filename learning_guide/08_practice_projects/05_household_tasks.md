# 8.5 í”„ë¡œì íŠ¸ 5: ê°€ì •ìš© ì‘ì—… ìë™í™”

ë³µì¡í•œ ê°€ì •ìš© ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” í†µí•© ë¡œë´‡ ì‹œìŠ¤í…œ êµ¬í˜„ í”„ë¡œì íŠ¸ì…ë‹ˆë‹¤.

## ğŸ¯ í”„ë¡œì íŠ¸ ëª©í‘œ

- í…Œì´ë¸” ì²­ì†Œ ìë™í™”
- ë¬¼ì²´ ì •ë¦¬ ë° ë¶„ë¥˜
- ì£¼ë°© ë³´ì¡° ì‘ì—…
- ë³µì¡í•œ ì‘ì—… ì‹œí€€ìŠ¤ ì‹¤í–‰
- ìƒí™© ì¸ì‹ ë° ì˜ì‚¬ ê²°ì •
- ì‹¤íŒ¨ ì²˜ë¦¬ ë° ë³µêµ¬

**ë‚œì´ë„**: â­â­â­â­â­ (ë§ˆìŠ¤í„°)  
**ì†Œìš” ì‹œê°„**: 3ì¼  
**ì„ ìˆ˜ ì§€ì‹**: 1-7ì¥, í”„ë¡œì íŠ¸ 1-4

---

## 1. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 1.1 ê°€ì •ìš© ë¡œë´‡ í†µí•© ì‹œìŠ¤í…œ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ê°€ì •ìš© ì‘ì—… ìë™í™” ì‹œìŠ¤í…œ                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  ì¸ì§€ ë ˆì´ì–´ (Perception)                                â”‚
â”‚  â”œâ”€ í™˜ê²½ ì´í•´ (Scene Understanding)                     â”‚
â”‚  â”œâ”€ ë¬¼ì²´ ì¸ì‹ ë° ë¶„ë¥˜                                    â”‚
â”‚  â”œâ”€ ê³µê°„ ë§¤í•‘                                           â”‚
â”‚  â””â”€ ìƒíƒœ ëª¨ë‹ˆí„°ë§                                       â”‚
â”‚                                                         â”‚
â”‚  ì‘ì—… ë ˆì´ì–´ (Task Planning)                             â”‚
â”‚  â”œâ”€ ì‘ì—… ë¶„í•´ (Task Decomposition)                      â”‚
â”‚  â”œâ”€ ìš°ì„ ìˆœìœ„ ê´€ë¦¬                                       â”‚
â”‚  â”œâ”€ ìŠ¤ì¼€ì¤„ë§                                            â”‚
â”‚  â””â”€ ì˜ì‚¬ ê²°ì •                                           â”‚
â”‚                                                         â”‚
â”‚  ì‹¤í–‰ ë ˆì´ì–´ (Execution)                                 â”‚
â”‚  â”œâ”€ ë„¤ë¹„ê²Œì´ì…˜ (í”„ë¡œì íŠ¸ 4)                             â”‚
â”‚  â”œâ”€ ì¡°ì‘ (í”„ë¡œì íŠ¸ 3)                                   â”‚
â”‚  â”œâ”€ ì¸ê°„-ë¡œë´‡ ìƒí˜¸ì‘ìš©                                  â”‚
â”‚  â””â”€ ì•ˆì „ ì œì–´                                           â”‚
â”‚                                                         â”‚
â”‚  í•™ìŠµ ë ˆì´ì–´ (Learning)                                  â”‚
â”‚  â”œâ”€ ê²½í—˜ ê¸°ë°˜ ê°œì„                                       â”‚
â”‚  â”œâ”€ ì‚¬ìš©ì ì„ í˜¸ë„ í•™ìŠµ                                  â”‚
â”‚  â””â”€ ì ì‘ì  í–‰ë™                                         â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 í•µì‹¬ ë°ì´í„° êµ¬ì¡°

**ì‘ì—… ê´€ë¦¬ ì‹œìŠ¤í…œ**
```python
import numpy as np
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Callable
from enum import Enum
import time

class TaskStatus(Enum):
    """ì‘ì—… ìƒíƒœ"""
    PENDING = 0      # ëŒ€ê¸° ì¤‘
    IN_PROGRESS = 1  # ì§„í–‰ ì¤‘
    COMPLETED = 2    # ì™„ë£Œ
    FAILED = 3       # ì‹¤íŒ¨
    CANCELLED = 4    # ì·¨ì†Œë¨

class TaskPriority(Enum):
    """ì‘ì—… ìš°ì„ ìˆœìœ„"""
    LOW = 0
    MEDIUM = 1
    HIGH = 2
    URGENT = 3

@dataclass
class Task:
    """ì‘ì—… ì •ì˜"""
    task_id: str
    name: str
    description: str
    priority: TaskPriority
    estimated_duration: float  # seconds
    prerequisites: List[str] = field(default_factory=list)
    subtasks: List['Task'] = field(default_factory=list)
    execution_function: Optional[Callable] = None
    status: TaskStatus = TaskStatus.PENDING
    progress: float = 0.0  # 0.0 ~ 1.0
    retry_count: int = 0
    max_retries: int = 3
    
    def execute(self, robot, context: Dict):
        """ì‘ì—… ì‹¤í–‰"""
        if self.execution_function is None:
            raise ValueError(f"ì‹¤í–‰ í•¨ìˆ˜ê°€ ì •ì˜ë˜ì§€ ì•ŠìŒ: {self.name}")
        
        self.status = TaskStatus.IN_PROGRESS
        
        try:
            result = self.execution_function(robot, context)
            
            if result:
                self.status = TaskStatus.COMPLETED
                self.progress = 1.0
                return True
            else:
                self.status = TaskStatus.FAILED
                return False
                
        except Exception as e:
            print(f"âŒ ì‘ì—… ì‹¤íŒ¨: {self.name} - {e}")
            self.status = TaskStatus.FAILED
            return False

@dataclass
class SceneObject:
    """ì¥ë©´ ë‚´ ë¬¼ì²´"""
    object_id: str
    class_name: str
    position: np.ndarray  # [x, y, z]
    orientation: np.ndarray
    dimensions: np.ndarray  # [width, height, depth]
    confidence: float
    is_movable: bool = True
    category: str = "unknown"  # tableware, food, cleaning, etc.
    
@dataclass
class WorkArea:
    """ì‘ì—… ì˜ì—­"""
    name: str
    bounds: np.ndarray  # [x_min, x_max, y_min, y_max, z_min, z_max]
    objects: List[SceneObject] = field(default_factory=list)
    is_accessible: bool = True
    purpose: str = "general"  # dining, kitchen, storage, etc.

class HouseholdRobotSystem:
    """ê°€ì •ìš© ë¡œë´‡ í†µí•© ì‹œìŠ¤í…œ"""
    
    def __init__(self, robot, sensors):
        self.robot = robot
        self.sensors = sensors
        
        # í•˜ìœ„ ì‹œìŠ¤í…œë“¤
        from project_3 import PickAndPlaceSystem
        from project_4 import NavigationController
        
        self.manipulation = PickAndPlaceSystem(robot, sensors['camera'])
        self.navigation = NavigationController(robot, sensors['lidar'])
        
        # ì‘ì—… ê´€ë¦¬
        self.task_queue: List[Task] = []
        self.completed_tasks: List[Task] = []
        self.current_task: Optional[Task] = None
        
        # í™˜ê²½ ëª¨ë¸
        self.work_areas: Dict[str, WorkArea] = {}
        self.known_objects: Dict[str, SceneObject] = {}
        
        # ìƒíƒœ
        self.is_busy = False
        self.battery_level = 100.0
        self.error_count = 0
        
    def add_task(self, task: Task):
        """ì‘ì—… ì¶”ê°€"""
        self.task_queue.append(task)
        
        # ìš°ì„ ìˆœìœ„ë¡œ ì •ë ¬
        self.task_queue.sort(key=lambda t: t.priority.value, reverse=True)
        
        print(f"ğŸ“‹ ì‘ì—… ì¶”ê°€: {task.name} (ìš°ì„ ìˆœìœ„: {task.priority.name})")
    
    def execute_tasks(self):
        """ì‘ì—… í ì‹¤í–‰"""
        print("ğŸ¤– ì‘ì—… ì‹¤í–‰ ì‹œì‘")
        
        while self.task_queue:
            # ë°°í„°ë¦¬ ì²´í¬
            if self.battery_level < 20:
                print("ğŸ”‹ ë°°í„°ë¦¬ ë¶€ì¡±, ì¶©ì „ í•„ìš”")
                self.go_to_charging_station()
                break
            
            # ë‹¤ìŒ ì‘ì—…
            task = self.task_queue.pop(0)
            self.current_task = task
            
            print(f"\n{'='*60}")
            print(f"  ì‹¤í–‰: {task.name}")
            print(f"  ìš°ì„ ìˆœìœ„: {task.priority.name}")
            print(f"  ì˜ˆìƒ ì‹œê°„: {task.estimated_duration:.1f}ì´ˆ")
            print(f"{'='*60}")
            
            # ì „ì œ ì¡°ê±´ í™•ì¸
            if not self.check_prerequisites(task):
                print(f"âš ï¸ ì „ì œ ì¡°ê±´ ë¯¸ì¶©ì¡±: {task.name}")
                task.status = TaskStatus.FAILED
                continue
            
            # ì‘ì—… ì‹¤í–‰
            success = self.execute_single_task(task)
            
            if success:
                print(f"âœ… ì™„ë£Œ: {task.name}")
                self.completed_tasks.append(task)
            else:
                print(f"âŒ ì‹¤íŒ¨: {task.name}")
                
                # ì¬ì‹œë„
                if task.retry_count < task.max_retries:
                    task.retry_count += 1
                    print(f"ğŸ”„ ì¬ì‹œë„ {task.retry_count}/{task.max_retries}")
                    self.task_queue.insert(0, task)  # ì•ì— ë‹¤ì‹œ ì¶”ê°€
                else:
                    print(f"âŒ ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼")
                    task.status = TaskStatus.FAILED
        
        self.current_task = None
        print("\nâœ… ëª¨ë“  ì‘ì—… ì™„ë£Œ!")
        
        # ìš”ì•½
        self.print_summary()
    
    def execute_single_task(self, task: Task) -> bool:
        """ë‹¨ì¼ ì‘ì—… ì‹¤í–‰"""
        
        # ì„œë¸ŒíƒœìŠ¤í¬ê°€ ìˆìœ¼ë©´ ìˆœì°¨ ì‹¤í–‰
        if task.subtasks:
            for i, subtask in enumerate(task.subtasks):
                print(f"  ğŸ”¸ ì„œë¸ŒíƒœìŠ¤í¬ {i+1}/{len(task.subtasks)}: {subtask.name}")
                
                success = self.execute_single_task(subtask)
                
                if not success:
                    return False
                
                # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                task.progress = (i + 1) / len(task.subtasks)
            
            task.status = TaskStatus.COMPLETED
            return True
        
        # ë‹¨ì¼ ì‘ì—… ì‹¤í–‰
        context = {
            'work_areas': self.work_areas,
            'known_objects': self.known_objects,
            'robot': self.robot,
            'sensors': self.sensors
        }
        
        return task.execute(self.robot, context)
    
    def check_prerequisites(self, task: Task) -> bool:
        """ì „ì œ ì¡°ê±´ í™•ì¸"""
        for prereq_id in task.prerequisites:
            # ì™„ë£Œëœ ì‘ì—… í™•ì¸
            completed_ids = [t.task_id for t in self.completed_tasks]
            
            if prereq_id not in completed_ids:
                return False
        
        return True
    
    def print_summary(self):
        """ì‘ì—… ìš”ì•½ ì¶œë ¥"""
        print("\n" + "="*60)
        print("  ì‘ì—… ìš”ì•½")
        print("="*60)
        
        completed = len([t for t in self.completed_tasks if t.status == TaskStatus.COMPLETED])
        failed = len([t for t in self.completed_tasks if t.status == TaskStatus.FAILED])
        
        print(f"ì™„ë£Œ: {completed}")
        print(f"ì‹¤íŒ¨: {failed}")
        print(f"ë°°í„°ë¦¬: {self.battery_level:.1f}%")
        print("="*60)
    
    def go_to_charging_station(self):
        """ì¶©ì „ì†Œë¡œ ì´ë™"""
        print("ğŸ”Œ ì¶©ì „ì†Œë¡œ ì´ë™ ì¤‘...")
        # êµ¬í˜„ ìƒëµ
```

---

## 2. ì‘ì—… 1: í…Œì´ë¸” ì²­ì†Œ

### 2.1 í…Œì´ë¸” ì²­ì†Œ ì‹œìŠ¤í…œ

**Table Cleaning Task**
```python
class TableCleaningTask:
    """í…Œì´ë¸” ì²­ì†Œ ì‘ì—…"""
    
    def __init__(self, robot_system: HouseholdRobotSystem):
        self.system = robot_system
        self.robot = robot_system.robot
        
    def create_task(self, table_area: WorkArea) -> Task:
        """í…Œì´ë¸” ì²­ì†Œ ì‘ì—… ìƒì„±"""
        
        # ì„œë¸ŒíƒœìŠ¤í¬ë“¤
        subtasks = [
            Task(
                task_id="detect_items",
                name="í…Œì´ë¸” ìœ„ ë¬¼ì²´ ê°ì§€",
                description="í…Œì´ë¸” ìœ„ì˜ ëª¨ë“  ë¬¼ì²´ë¥¼ ê°ì§€í•˜ê³  ë¶„ë¥˜",
                priority=TaskPriority.HIGH,
                estimated_duration=10.0,
                execution_function=self.detect_table_items
            ),
            Task(
                task_id="classify_items",
                name="ë¬¼ì²´ ë¶„ë¥˜",
                description="ë¬¼ì²´ë¥¼ ìœ ì§€/ì œê±°/ì¬ë°°ì¹˜ë¡œ ë¶„ë¥˜",
                priority=TaskPriority.MEDIUM,
                estimated_duration=5.0,
                execution_function=self.classify_items
            ),
            Task(
                task_id="remove_trash",
                name="ì“°ë ˆê¸° ì œê±°",
                description="ì“°ë ˆê¸°ë¥¼ ì“°ë ˆê¸°í†µìœ¼ë¡œ ì´ë™",
                priority=TaskPriority.HIGH,
                estimated_duration=30.0,
                execution_function=self.remove_trash_items
            ),
            Task(
                task_id="organize_items",
                name="ë¬¼ì²´ ì •ë¦¬",
                description="ë¬¼ì²´ë¥¼ ì ì ˆí•œ ìœ„ì¹˜ë¡œ ì´ë™",
                priority=TaskPriority.MEDIUM,
                estimated_duration=60.0,
                execution_function=self.organize_items
            ),
            Task(
                task_id="wipe_table",
                name="í…Œì´ë¸” ë‹¦ê¸°",
                description="í…Œì´ë¸” í‘œë©´ì„ ë‹¦ê¸°",
                priority=TaskPriority.LOW,
                estimated_duration=20.0,
                execution_function=self.wipe_table_surface
            ),
        ]
        
        main_task = Task(
            task_id="clean_table",
            name="í…Œì´ë¸” ì²­ì†Œ",
            description=f"{table_area.name} ì™„ì „ ì²­ì†Œ",
            priority=TaskPriority.HIGH,
            estimated_duration=125.0,
            subtasks=subtasks
        )
        
        return main_task
    
    def detect_table_items(self, robot, context: Dict) -> bool:
        """í…Œì´ë¸” ìœ„ ë¬¼ì²´ ê°ì§€"""
        print("  ğŸ“· ë¬¼ì²´ ê°ì§€ ì¤‘...")
        
        # ì¹´ë©”ë¼ ì´ë¯¸ì§€ íšë“
        rgb = context['sensors']['camera'].get_rgb()
        depth = context['sensors']['camera'].get_depth()
        
        # ë¬¼ì²´ ê°ì§€
        detections = self.system.manipulation.detector.detect(rgb)
        
        # 3D í¬ì¦ˆ ì¶”ì •
        detected_objects = []
        
        for det in detections:
            obj_3d = self.system.manipulation.pose_estimator.estimate_3d_pose(
                det, depth
            )
            
            # í…Œì´ë¸” ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
            table_height = 0.75  # 75cm
            if abs(obj_3d.position_3d[2] - table_height) < 0.1:
                scene_obj = SceneObject(
                    object_id=f"obj_{len(detected_objects)}",
                    class_name=obj_3d.class_name,
                    position=obj_3d.position_3d,
                    orientation=obj_3d.orientation_3d,
                    dimensions=obj_3d.dimensions,
                    confidence=obj_3d.confidence
                )
                detected_objects.append(scene_obj)
        
        # ì»¨í…ìŠ¤íŠ¸ì— ì €ì¥
        context['detected_objects'] = detected_objects
        
        print(f"  âœ“ {len(detected_objects)}ê°œ ë¬¼ì²´ ë°œê²¬")
        
        return True
    
    def classify_items(self, robot, context: Dict) -> bool:
        """ë¬¼ì²´ ë¶„ë¥˜"""
        print("  ğŸ·ï¸  ë¬¼ì²´ ë¶„ë¥˜ ì¤‘...")
        
        detected_objects = context.get('detected_objects', [])
        
        # ë¶„ë¥˜ ê·œì¹™
        trash_items = ['bottle', 'cup', 'wrapper']
        keep_items = ['laptop', 'book', 'phone']
        organize_items = ['remote', 'pen', 'notebook']
        
        classified = {
            'trash': [],
            'keep': [],
            'organize': []
        }
        
        for obj in detected_objects:
            if obj.class_name in trash_items:
                obj.category = 'trash'
                classified['trash'].append(obj)
            elif obj.class_name in keep_items:
                obj.category = 'keep'
                classified['keep'].append(obj)
            else:
                obj.category = 'organize'
                classified['organize'].append(obj)
        
        context['classified_objects'] = classified
        
        print(f"  âœ“ ì“°ë ˆê¸°: {len(classified['trash'])}, "
              f"ë³´ê´€: {len(classified['keep'])}, "
              f"ì •ë¦¬: {len(classified['organize'])}")
        
        return True
    
    def remove_trash_items(self, robot, context: Dict) -> bool:
        """ì“°ë ˆê¸° ì œê±°"""
        print("  ğŸ—‘ï¸  ì“°ë ˆê¸° ì œê±° ì¤‘...")
        
        classified = context.get('classified_objects', {})
        trash_items = classified.get('trash', [])
        
        # ì“°ë ˆê¸°í†µ ìœ„ì¹˜
        trash_bin_position = np.array([1.5, -1.0, 0.3])
        
        for i, obj in enumerate(trash_items):
            print(f"    {i+1}/{len(trash_items)}: {obj.class_name}")
            
            # í”½ì•¤í”Œë ˆì´ìŠ¤
            success = self.system.manipulation.execute_pick_and_place(
                obj.class_name,
                trash_bin_position
            )
            
            if not success:
                print(f"    âš ï¸ ì‹¤íŒ¨: {obj.class_name}")
                continue
            
            time.sleep(1)
        
        print(f"  âœ“ {len(trash_items)}ê°œ ì“°ë ˆê¸° ì œê±° ì™„ë£Œ")
        
        return True
    
    def organize_items(self, robot, context: Dict) -> bool:
        """ë¬¼ì²´ ì •ë¦¬"""
        print("  ğŸ“¦ ë¬¼ì²´ ì •ë¦¬ ì¤‘...")
        
        classified = context.get('classified_objects', {})
        organize_items = classified.get('organize', [])
        
        # ì •ë¦¬ ìœ„ì¹˜ (í…Œì´ë¸” í•œìª½)
        organize_positions = [
            np.array([0.8, 0.3, 0.75]),
            np.array([0.8, 0.4, 0.75]),
            np.array([0.9, 0.3, 0.75]),
            np.array([0.9, 0.4, 0.75]),
        ]
        
        for i, obj in enumerate(organize_items):
            if i >= len(organize_positions):
                break
            
            print(f"    {i+1}/{len(organize_items)}: {obj.class_name}")
            
            # ëª©í‘œ ìœ„ì¹˜
            target_pos = organize_positions[i]
            
            # í”½ì•¤í”Œë ˆì´ìŠ¤
            success = self.system.manipulation.execute_pick_and_place(
                obj.class_name,
                target_pos
            )
            
            if not success:
                print(f"    âš ï¸ ì‹¤íŒ¨: {obj.class_name}")
                continue
            
            time.sleep(1)
        
        print(f"  âœ“ {len(organize_items)}ê°œ ë¬¼ì²´ ì •ë¦¬ ì™„ë£Œ")
        
        return True
    
    def wipe_table_surface(self, robot, context: Dict) -> bool:
        """í…Œì´ë¸” í‘œë©´ ë‹¦ê¸°"""
        print("  ğŸ§¹ í…Œì´ë¸” ë‹¦ëŠ” ì¤‘...")
        
        # ì²œ ë˜ëŠ” ìŠ¤í€ì§€ ì¡ê¸°
        cloth_position = np.array([1.0, 0.5, 0.75])
        
        # ê·¸ë¦¬í¼ë¡œ ì²œ ì¡ê¸° (ê°„ë‹¨í•œ ë²„ì „)
        robot.move_to_position(cloth_position)
        robot.close_gripper()
        
        # ì§€ê·¸ì¬ê·¸ íŒ¨í„´ìœ¼ë¡œ ë‹¦ê¸°
        table_area = [
            (0.3, 0.0), (0.7, 0.0),
            (0.7, 0.2), (0.3, 0.2),
            (0.3, 0.4), (0.7, 0.4),
        ]
        
        table_height = 0.76  # í…Œì´ë¸”ë³´ë‹¤ ì‚´ì§ ë†’ê²Œ
        
        for x, y in table_area:
            position = np.array([x, y, table_height])
            robot.move_to_position(position)
            time.sleep(0.5)
        
        # ì²œ ë†“ê¸°
        robot.open_gripper()
        
        print("  âœ“ í…Œì´ë¸” ì²­ì†Œ ì™„ë£Œ")
        
        return True
```

---

## 3. ì‘ì—… 2: ë¬¼ì²´ ì •ë¦¬ ë° ë¶„ë¥˜

### 3.1 ì§€ëŠ¥í˜• ë¬¼ì²´ ì •ë¦¬

**Object Sorting System**
```python
class ObjectSortingTask:
    """ë¬¼ì²´ ì •ë¦¬ ë° ë¶„ë¥˜ ì‘ì—…"""
    
    def __init__(self, robot_system: HouseholdRobotSystem):
        self.system = robot_system
        self.robot = robot_system.robot
        
        # ì¹´í…Œê³ ë¦¬ë³„ ì €ì¥ ìœ„ì¹˜
        self.storage_locations = {
            'books': np.array([2.0, 1.0, 0.5]),
            'electronics': np.array([2.0, 0.5, 0.5]),
            'kitchen': np.array([1.5, 0.0, 0.5]),
            'toys': np.array([2.0, 1.5, 0.3]),
            'clothes': np.array([1.8, 1.0, 0.7]),
            'tools': np.array([2.2, 0.5, 0.4]),
        }
        
    def create_task(self) -> Task:
        """ë¬¼ì²´ ì •ë¦¬ ì‘ì—… ìƒì„±"""
        
        return Task(
            task_id="sort_objects",
            name="ë¬¼ì²´ ì •ë¦¬ ë° ë¶„ë¥˜",
            description="ë°©ì— í©ì–´ì§„ ë¬¼ì²´ë“¤ì„ ì¹´í…Œê³ ë¦¬ë³„ë¡œ ì •ë¦¬",
            priority=TaskPriority.MEDIUM,
            estimated_duration=180.0,
            execution_function=self.execute_sorting
        )
    
    def execute_sorting(self, robot, context: Dict) -> bool:
        """ë¬¼ì²´ ì •ë¦¬ ì‹¤í–‰"""
        print("  ğŸ” ë¬¼ì²´ ìŠ¤ìº” ì¤‘...")
        
        # 1. ë°© ì „ì²´ ìŠ¤ìº”
        objects = self.scan_room(context)
        
        print(f"  âœ“ {len(objects)}ê°œ ë¬¼ì²´ ë°œê²¬")
        
        # 2. ì¹´í…Œê³ ë¦¬ë³„ ë¶„ë¥˜
        categorized = self.categorize_objects(objects)
        
        # 3. ê° ì¹´í…Œê³ ë¦¬ë³„ë¡œ ì •ë¦¬
        for category, items in categorized.items():
            if not items:
                continue
            
            print(f"\n  ğŸ“¦ {category} ì •ë¦¬ ì¤‘... ({len(items)}ê°œ)")
            
            target_location = self.storage_locations.get(
                category, 
                np.array([2.0, 0.0, 0.5])  # ê¸°ë³¸ ìœ„ì¹˜
            )
            
            for i, obj in enumerate(items):
                print(f"    {i+1}/{len(items)}: {obj.class_name}")
                
                # ì•½ê°„ì”© ìœ„ì¹˜ ì¡°ì • (ê²¹ì¹˜ì§€ ì•Šê²Œ)
                offset = np.array([0, i * 0.1, 0])
                place_pos = target_location + offset
                
                # ë¬¼ì²´ ì¡ê³  ì´ë™
                success = self.system.manipulation.execute_pick_and_place(
                    obj.class_name,
                    place_pos
                )
                
                if not success:
                    print(f"    âš ï¸ ì‹¤íŒ¨: {obj.class_name}")
                    continue
                
                time.sleep(0.5)
        
        print("  âœ… ë¬¼ì²´ ì •ë¦¬ ì™„ë£Œ")
        
        return True
    
    def scan_room(self, context: Dict) -> List[SceneObject]:
        """ë°© ì „ì²´ ìŠ¤ìº”"""
        
        # ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ ìŠ¤ìº”
        scan_positions = [
            Pose2D(0.0, 0.0, 0.0),
            Pose2D(1.0, 1.0, np.pi/2),
            Pose2D(2.0, 0.0, np.pi),
            Pose2D(1.0, -1.0, -np.pi/2),
        ]
        
        all_objects = []
        
        for pos in scan_positions:
            # ìœ„ì¹˜ë¡œ ì´ë™
            self.system.navigation.navigate_to(pos)
            
            # ë¬¼ì²´ ê°ì§€
            rgb = context['sensors']['camera'].get_rgb()
            depth = context['sensors']['camera'].get_depth()
            
            detections = self.system.manipulation.detector.detect(rgb)
            
            for det in detections:
                obj = self.system.manipulation.pose_estimator.estimate_3d_pose(
                    det, depth
                )
                
                scene_obj = SceneObject(
                    object_id=f"obj_{len(all_objects)}",
                    class_name=obj.class_name,
                    position=obj.position_3d,
                    orientation=obj.orientation_3d,
                    dimensions=obj.dimensions,
                    confidence=obj.confidence
                )
                
                all_objects.append(scene_obj)
        
        # ì¤‘ë³µ ì œê±° (ê°™ì€ ìœ„ì¹˜ì˜ ë¬¼ì²´)
        unique_objects = self.remove_duplicates(all_objects)
        
        return unique_objects
    
    def remove_duplicates(self, objects: List[SceneObject], 
                         threshold: float = 0.2) -> List[SceneObject]:
        """ì¤‘ë³µ ë¬¼ì²´ ì œê±°"""
        
        unique = []
        
        for obj in objects:
            is_duplicate = False
            
            for unique_obj in unique:
                distance = np.linalg.norm(obj.position - unique_obj.position)
                
                if distance < threshold and obj.class_name == unique_obj.class_name:
                    is_duplicate = True
                    break
            
            if not is_duplicate:
                unique.append(obj)
        
        return unique
    
    def categorize_objects(self, objects: List[SceneObject]) -> Dict[str, List[SceneObject]]:
        """ë¬¼ì²´ ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜"""
        
        # ë¶„ë¥˜ ê·œì¹™
        category_mapping = {
            'book': 'books',
            'laptop': 'electronics',
            'phone': 'electronics',
            'remote': 'electronics',
            'bottle': 'kitchen',
            'cup': 'kitchen',
            'bowl': 'kitchen',
            'teddy bear': 'toys',
            'frisbee': 'toys',
        }
        
        categorized = {cat: [] for cat in self.storage_locations.keys()}
        categorized['misc'] = []  # ê¸°íƒ€
        
        for obj in objects:
            category = category_mapping.get(obj.class_name, 'misc')
            obj.category = category
            categorized[category].append(obj)
        
        return categorized
```

---

## 4. ì‘ì—… 3: ì£¼ë°© ë³´ì¡°

### 4.1 ì£¼ë°© ì‘ì—… ì‹œìŠ¤í…œ

**Kitchen Assistant**
```python
class KitchenAssistantTask:
    """ì£¼ë°© ë³´ì¡° ì‘ì—…"""
    
    def __init__(self, robot_system: HouseholdRobotSystem):
        self.system = robot_system
        self.robot = robot_system.robot
        
    def create_dishwashing_task(self) -> Task:
        """ì„¤ê±°ì§€ ë³´ì¡° ì‘ì—…"""
        
        subtasks = [
            Task(
                task_id="collect_dishes",
                name="ì‹ê¸° ìˆ˜ì§‘",
                description="í…Œì´ë¸”ì—ì„œ ì‚¬ìš©í•œ ì‹ê¸° ìˆ˜ì§‘",
                priority=TaskPriority.HIGH,
                estimated_duration=60.0,
                execution_function=self.collect_dishes
            ),
            Task(
                task_id="load_dishwasher",
                name="ì‹ê¸°ì„¸ì²™ê¸° ì ì¬",
                description="ì‹ê¸°ë¥¼ ì‹ê¸°ì„¸ì²™ê¸°ì— ë°°ì¹˜",
                priority=TaskPriority.MEDIUM,
                estimated_duration=90.0,
                execution_function=self.load_dishwasher
            ),
        ]
        
        return Task(
            task_id="dishwashing",
            name="ì„¤ê±°ì§€ ë³´ì¡°",
            description="ì‹ì‚¬ í›„ ì„¤ê±°ì§€ ì‘ì—…",
            priority=TaskPriority.MEDIUM,
            estimated_duration=150.0,
            subtasks=subtasks
        )
    
    def create_meal_prep_task(self) -> Task:
        """ì‹ì‚¬ ì¤€ë¹„ ë³´ì¡°"""
        
        subtasks = [
            Task(
                task_id="get_ingredients",
                name="ì¬ë£Œ ê°€ì ¸ì˜¤ê¸°",
                description="í•„ìš”í•œ ì¬ë£Œë¥¼ ëƒ‰ì¥ê³ /ì„ ë°˜ì—ì„œ ê°€ì ¸ì˜¤ê¸°",
                priority=TaskPriority.HIGH,
                estimated_duration=120.0,
                execution_function=self.get_ingredients
            ),
            Task(
                task_id="arrange_workspace",
                name="ì‘ì—… ê³µê°„ ì •ë¦¬",
                description="ì¡°ë¦¬ëŒ€ ìœ„ ì •ë¦¬ ë° ë„êµ¬ ë°°ì¹˜",
                priority=TaskPriority.MEDIUM,
                estimated_duration=60.0,
                execution_function=self.arrange_workspace
            ),
        ]
        
        return Task(
            task_id="meal_prep",
            name="ì‹ì‚¬ ì¤€ë¹„ ë³´ì¡°",
            description="ìš”ë¦¬ë¥¼ ìœ„í•œ ì¤€ë¹„ ì‘ì—…",
            priority=TaskPriority.HIGH,
            estimated_duration=180.0,
            subtasks=subtasks
        )
    
    def collect_dishes(self, robot, context: Dict) -> bool:
        """ì‹ê¸° ìˆ˜ì§‘"""
        print("  ğŸ½ï¸  ì‹ê¸° ìˆ˜ì§‘ ì¤‘...")
        
        # ì‹íƒ ìœ„ ì‹ê¸° ê°ì§€
        rgb = context['sensors']['camera'].get_rgb()
        depth = context['sensors']['camera'].get_depth()
        
        detections = self.system.manipulation.detector.detect(rgb)
        
        # ì‹ê¸° í•„í„°ë§
        dish_classes = ['cup', 'bowl', 'plate', 'fork', 'knife', 'spoon']
        dishes = []
        
        for det in detections:
            if det['class_name'] in dish_classes:
                obj = self.system.manipulation.pose_estimator.estimate_3d_pose(
                    det, depth
                )
                dishes.append(obj)
        
        print(f"  âœ“ {len(dishes)}ê°œ ì‹ê¸° ë°œê²¬")
        
        # ì‹±í¬ëŒ€ ìœ„ì¹˜
        sink_position = np.array([1.8, 0.0, 0.85])
        
        # ê° ì‹ê¸°ë¥¼ ì‹±í¬ëŒ€ë¡œ ì´ë™
        for i, dish in enumerate(dishes):
            print(f"    {i+1}/{len(dishes)}: {dish.class_name}")
            
            # ìŒ“ê¸° (ë†’ì´ ì¡°ì •)
            place_pos = sink_position.copy()
            place_pos[2] += i * 0.05  # 5cmì”© ë†’ì´ ì¦ê°€
            
            success = self.system.manipulation.execute_pick_and_place(
                dish.class_name,
                place_pos
            )
            
            if not success:
                print(f"    âš ï¸ ì‹¤íŒ¨: {dish.class_name}")
            
            time.sleep(1)
        
        print("  âœ… ì‹ê¸° ìˆ˜ì§‘ ì™„ë£Œ")
        
        return True
    
    def load_dishwasher(self, robot, context: Dict) -> bool:
        """ì‹ê¸°ì„¸ì²™ê¸° ì ì¬"""
        print("  ï¿½ï¿½ ì‹ê¸°ì„¸ì²™ê¸° ì ì¬ ì¤‘...")
        
        # ì‹±í¬ëŒ€ì˜ ì‹ê¸°ë“¤
        sink_position = np.array([1.8, 0.0, 0.85])
        
        # ì‹ê¸°ì„¸ì²™ê¸° ë™ ìœ„ì¹˜ë“¤
        dishwasher_positions = [
            np.array([2.0, -0.3, 0.6]),  # ì•„ë˜ ë™
            np.array([2.0, -0.2, 0.6]),
            np.array([2.0, -0.1, 0.6]),
            np.array([2.0, 0.0, 0.6]),
            np.array([2.0, -0.3, 0.9]),  # ìœ„ ë™
            np.array([2.0, -0.2, 0.9]),
        ]
        
        # ì‹ê¸° ì´ë™
        for i, target_pos in enumerate(dishwasher_positions):
            print(f"    {i+1}/{len(dishwasher_positions)} ìœ„ì¹˜")
            
            # ì‹±í¬ëŒ€ì—ì„œ ì¡ê¸°
            pick_pos = sink_position.copy()
            pick_pos[2] += (len(dishwasher_positions) - i - 1) * 0.05
            
            robot.move_to_position(pick_pos)
            robot.close_gripper()
            
            # ì‹ê¸°ì„¸ì²™ê¸°ë¡œ ì´ë™
            robot.move_to_position(target_pos)
            robot.open_gripper()
            
            time.sleep(1)
        
        print("  âœ… ì‹ê¸°ì„¸ì²™ê¸° ì ì¬ ì™„ë£Œ")
        
        return True
    
    def get_ingredients(self, robot, context: Dict) -> bool:
        """ì¬ë£Œ ê°€ì ¸ì˜¤ê¸°"""
        print("  ï¿½ï¿½ ì¬ë£Œ ê°€ì ¸ì˜¤ëŠ” ì¤‘...")
        
        # í•„ìš”í•œ ì¬ë£Œ ë¦¬ìŠ¤íŠ¸ (ì˜ˆì‹œ)
        ingredients = [
            {'name': 'apple', 'location': np.array([2.5, 1.0, 1.2])},  # ëƒ‰ì¥ê³ 
            {'name': 'bottle', 'location': np.array([2.5, 1.1, 1.2])},
            {'name': 'bowl', 'location': np.array([2.2, 0.5, 0.8])},   # ì„ ë°˜
        ]
        
        # ì¡°ë¦¬ëŒ€ ìœ„ì¹˜
        counter_position = np.array([1.5, 0.0, 0.85])
        
        for i, ingredient in enumerate(ingredients):
            print(f"    {i+1}/{len(ingredients)}: {ingredient['name']}")
            
            # ì¬ë£Œ ìœ„ì¹˜ë¡œ ì´ë™
            self.system.navigation.navigate_to(
                Pose2D(ingredient['location'][0], 
                      ingredient['location'][1], 
                      0.0)
            )
            
            # ì¬ë£Œ ì¡ê¸°
            robot.move_to_position(ingredient['location'])
            robot.close_gripper()
            
            # ì¡°ë¦¬ëŒ€ë¡œ ì´ë™
            place_pos = counter_position.copy()
            place_pos[0] += i * 0.15  # ì˜†ìœ¼ë¡œ ë°°ì¹˜
            
            self.system.navigation.navigate_to(
                Pose2D(place_pos[0], place_pos[1], 0.0)
            )
            
            robot.move_to_position(place_pos)
            robot.open_gripper()
            
            time.sleep(1)
        
        print("  âœ… ì¬ë£Œ ì¤€ë¹„ ì™„ë£Œ")
        
        return True
    
    def arrange_workspace(self, robot, context: Dict) -> bool:
        """ì‘ì—… ê³µê°„ ì •ë¦¬"""
        print("  ğŸ§¹ ì‘ì—… ê³µê°„ ì •ë¦¬ ì¤‘...")
        
        # ì¡°ë¦¬ëŒ€ ì²­ì†Œ (ê°„ë‹¨í•œ ë²„ì „)
        # ì‹¤ì œë¡œëŠ” ë¬¼ì²´ ê°ì§€ â†’ ë¶„ë¥˜ â†’ ì •ë¦¬
        
        counter_area = WorkArea(
            name="counter",
            bounds=np.array([1.2, 1.8, -0.3, 0.3, 0.8, 1.0])
        )
        
        # ì¡°ë¦¬ëŒ€ ìœ„ ë¬¼ì²´ ê°ì§€
        rgb = context['sensors']['camera'].get_rgb()
        depth = context['sensors']['camera'].get_depth()
        
        detections = self.system.manipulation.detector.detect(rgb)
        
        # í•„ìš” ì—†ëŠ” ë¬¼ì²´ ì œê±°
        unwanted_classes = ['bottle', 'wrapper', 'book']
        
        for det in detections:
            if det['class_name'] in unwanted_classes:
                obj = self.system.manipulation.pose_estimator.estimate_3d_pose(
                    det, depth
                )
                
                # ë‹¤ë¥¸ ê³³ìœ¼ë¡œ ì´ë™
                storage_pos = np.array([2.0, 1.0, 0.5])
                
                self.system.manipulation.execute_pick_and_place(
                    obj.class_name,
                    storage_pos
                )
        
        print("  âœ… ì‘ì—… ê³µê°„ ì •ë¦¬ ì™„ë£Œ")
        
        return True
```

---

## 5. í†µí•© ë°ëª¨

### 5.1 ì¼ì¼ ê°€ì‚¬ ë£¨í‹´

**Daily Routine**
```python
def daily_household_routine():
    """ì¼ì¼ ê°€ì‚¬ ë£¨í‹´"""
    
    print("=" * 70)
    print("  ğŸ  XLeRobot ê°€ì •ìš© ì‘ì—… ìë™í™” ì‹œìŠ¤í…œ")
    print("  ì¼ì¼ ê°€ì‚¬ ë£¨í‹´")
    print("=" * 70)
    
    # ë¡œë´‡ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    robot = XLeRobot()
    sensors = {
        'camera': RGBDCamera(),
        'lidar': SimulatedLidar()
    }
    
    system = HouseholdRobotSystem(robot, sensors)
    
    # ì‘ì—… ì˜ì—­ ì •ì˜
    system.work_areas = {
        'dining_table': WorkArea(
            name="ì‹íƒ",
            bounds=np.array([0.3, 1.0, -0.4, 0.4, 0.7, 0.8]),
            purpose="dining"
        ),
        'kitchen_counter': WorkArea(
            name="ì¡°ë¦¬ëŒ€",
            bounds=np.array([1.2, 1.8, -0.3, 0.3, 0.8, 1.0]),
            purpose="kitchen"
        ),
        'living_room': WorkArea(
            name="ê±°ì‹¤",
            bounds=np.array([0.0, 3.0, -2.0, 2.0, 0.0, 0.5]),
            purpose="living"
        ),
    }
    
    # ì‘ì—… ìƒì„±ìë“¤
    table_cleaner = TableCleaningTask(system)
    object_sorter = ObjectSortingTask(system)
    kitchen_assistant = KitchenAssistantTask(system)
    
    # ì•„ì¹¨ ë£¨í‹´
    print("\nğŸŒ… ì•„ì¹¨ ë£¨í‹´ ì‹œì‘")
    print("-" * 70)
    
    morning_tasks = [
        kitchen_assistant.create_meal_prep_task(),
        table_cleaner.create_task(system.work_areas['dining_table']),
    ]
    
    for task in morning_tasks:
        system.add_task(task)
    
    system.execute_tasks()
    
    # ì ì‹¬ ë£¨í‹´
    print("\nâ˜€ï¸ ì ì‹¬ ë£¨í‹´ ì‹œì‘")
    print("-" * 70)
    
    lunch_tasks = [
        kitchen_assistant.create_dishwashing_task(),
        table_cleaner.create_task(system.work_areas['dining_table']),
    ]
    
    for task in lunch_tasks:
        system.add_task(task)
    
    system.execute_tasks()
    
    # ì €ë… ë£¨í‹´
    print("\nğŸŒ™ ì €ë… ë£¨í‹´ ì‹œì‘")
    print("-" * 70)
    
    evening_tasks = [
        kitchen_assistant.create_dishwashing_task(),
        object_sorter.create_task(),
        table_cleaner.create_task(system.work_areas['dining_table']),
    ]
    
    for task in evening_tasks:
        system.add_task(task)
    
    system.execute_tasks()
    
    # ìµœì¢… ìš”ì•½
    print("\n" + "=" * 70)
    print("  ğŸ“Š ì¼ì¼ ì‘ì—… ìš”ì•½")
    print("=" * 70)
    
    total_tasks = len(system.completed_tasks)
    successful = len([t for t in system.completed_tasks 
                     if t.status == TaskStatus.COMPLETED])
    
    print(f"ì´ ì‘ì—…: {total_tasks}")
    print(f"ì„±ê³µ: {successful}")
    print(f"ì„±ê³µë¥ : {successful/total_tasks*100:.1f}%")
    print(f"ë°°í„°ë¦¬ ì”ëŸ‰: {system.battery_level:.1f}%")
    print("=" * 70)

if __name__ == "__main__":
    daily_household_routine()
```

### 5.2 ëŒ€í™”í˜• ì‘ì—… ì‹œìŠ¤í…œ

**Voice Command Interface**
```python
def voice_command_household_system():
    """ìŒì„± ëª…ë ¹ ê¸°ë°˜ ê°€ì‚¬ ì‹œìŠ¤í…œ"""
    
    import speech_recognition as sr
    
    robot = XLeRobot()
    sensors = {'camera': RGBDCamera(), 'lidar': SimulatedLidar()}
    system = HouseholdRobotSystem(robot, sensors)
    
    # ì‘ì—… ë§¤í•‘
    task_creators = {
        'í…Œì´ë¸” ì²­ì†Œ': lambda: TableCleaningTask(system).create_task(
            system.work_areas['dining_table']
        ),
        'ë¬¼ì²´ ì •ë¦¬': lambda: ObjectSortingTask(system).create_task(),
        'ì„¤ê±°ì§€': lambda: KitchenAssistantTask(system).create_dishwashing_task(),
        'ì‹ì‚¬ ì¤€ë¹„': lambda: KitchenAssistantTask(system).create_meal_prep_task(),
    }
    
    recognizer = sr.Recognizer()
    microphone = sr.Microphone()
    
    print("ğŸ¤ ìŒì„± ëª…ë ¹ ëŒ€ê¸° ì¤‘...")
    print("ëª…ë ¹ì–´: 'í…Œì´ë¸” ì²­ì†Œ', 'ë¬¼ì²´ ì •ë¦¬', 'ì„¤ê±°ì§€', 'ì‹ì‚¬ ì¤€ë¹„', 'ì¢…ë£Œ'")
    
    while True:
        with microphone as source:
            recognizer.adjust_for_ambient_noise(source)
            
            try:
                audio = recognizer.listen(source, timeout=5)
                command = recognizer.recognize_google(audio, language='ko-KR')
                
                print(f"\nğŸ“ ëª…ë ¹: {command}")
                
                if 'ì¢…ë£Œ' in command:
                    print("ğŸ‘‹ ì‹œìŠ¤í…œ ì¢…ë£Œ")
                    break
                
                # ì‘ì—… ë§¤ì¹­
                task_created = False
                for task_name, creator in task_creators.items():
                    if task_name in command:
                        task = creator()
                        system.add_task(task)
                        task_created = True
                        break
                
                if task_created:
                    print("âœ… ì‘ì—… ì¶”ê°€ë¨")
                    
                    # ì¦‰ì‹œ ì‹¤í–‰ ì—¬ë¶€
                    if 'ì§€ê¸ˆ' in command or 'ë°”ë¡œ' in command:
                        system.execute_tasks()
                else:
                    print("â“ ëª…ë ¹ì„ ì´í•´í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤")
                    
            except sr.WaitTimeoutError:
                continue
            except sr.UnknownValueError:
                print("â“ ìŒì„±ì„ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤")
            except Exception as e:
                print(f"âŒ ì˜¤ë¥˜: {e}")
```

---

## âœ… í”„ë¡œì íŠ¸ 5 ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] í…Œì´ë¸” ì²­ì†Œ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ë¬¼ì²´ ì •ë¦¬ ë° ë¶„ë¥˜ êµ¬í˜„
- [ ] ì£¼ë°© ë³´ì¡° ì‘ì—… êµ¬í˜„
- [ ] ì‘ì—… ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì¼ì¼ ë£¨í‹´ ìë™í™”
- [ ] ìŒì„± ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤
- [ ] ì‹¤íŒ¨ ì²˜ë¦¬ ë° ë³µêµ¬
- [ ] í†µí•© í…ŒìŠ¤íŠ¸

## ğŸ“ í•™ìŠµ ì •ë¦¬

1. **ì‘ì—… ê³„íš**: ë³µì¡í•œ ì‘ì—…ì„ ì„œë¸ŒíƒœìŠ¤í¬ë¡œ ë¶„í•´
2. **ì‹œìŠ¤í…œ í†µí•©**: ë„¤ë¹„ê²Œì´ì…˜ + ì¡°ì‘ + ì¸ì‹ í†µí•©
3. **ìƒí™© ì¸ì‹**: í™˜ê²½ ì´í•´ ë° ì ì‘ì  í–‰ë™
4. **ì•ˆì •ì„±**: ì‹¤íŒ¨ ì²˜ë¦¬ ë° ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜
5. **ì‹¤ìš©ì„±**: ì‹¤ì œ ê°€ì • í™˜ê²½ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œìŠ¤í…œ

---

[â† 8.4 ììœ¨ ë„¤ë¹„ê²Œì´ì…˜](04_navigation.md) | [ë‹¤ìŒ: 8.6 ë‹¤ìŒ ë‹¨ê³„ â†’](06_next_steps.md)
